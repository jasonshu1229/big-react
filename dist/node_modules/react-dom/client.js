(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.React));
})(this, (function (React) { 'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

	const FunctionComponent = 0;
	const HostRoot = 3; // Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素
	const HostComponent = 5; // dom元素 比如 <div></div>
	const HostText = 6; // 文本类型 比如：<div>123</div>

	// 每个 flag 占一个位
	const NoFlags = 0b0000000; // 当前没有标记
	const Placement = 0b0000001; // 插入
	const Update = 0b0000010; // 更新属性
	const ChildDeletion = 0b0000100; // 删除子节点
	// 如果当前节点 child flags 和 subtreeFlags 包括下面这三个副作用，则表示需要执行 mutation 阶段
	const MutationMask = Placement | Update | ChildDeletion; // 变更标记

	// ReactElement 对象的每个节点都会生成与之对应的 FiberNode
	// React针对不同的 ReactElement 对象会产生不同tag（种类）的 FiberNode
	// fiber.ts 存放 FiberNode 的数据结构
	class FiberNode {
	    // 跟自身有关的属性
	    type;
	    tag;
	    pendingProps;
	    key;
	    ref;
	    stateNode;
	    // 跟工作单元其它节点有关的属性
	    return;
	    sibling;
	    child;
	    index;
	    memoizedProps;
	    memoizedState;
	    alternate; // 双缓冲树的切换
	    subtreeFlags; // 子树中包含的flags
	    flags; // fiberNode 双缓冲树对比之后产生的标记，比如插入，移动，删除等
	    updateQueue;
	    // pendingProps 有哪些 props 需要改变
	    // key：对应的是 ReactElement 的 key
	    constructor(tag, pendingProps, key) {
	        // 实例自身上的属性
	        this.tag = tag;
	        this.key = key;
	        // HostComponent <div> => Dom
	        this.stateNode = null;
	        // FunctionComponent () => 这个函数本身
	        this.type = null;
	        this.ref = null;
	        // fiber 除了有自身实例上的属性，还需要有表示和其它节点的关系
	        // 作为树状结构
	        // 一个子级 fiberNode 指向 父级 FiberNode：表示子 fiberNode 工作结束后要 return 到父fiberNode工作
	        this.return = null;
	        // 右边的兄弟 fiberNode
	        this.sibling = null;
	        // 子 fiberNode
	        this.child = null;
	        // <li>1</li> <li>2</li> 表示它的序号
	        this.index = 0;
	        // 作为工作单元
	        this.pendingProps = pendingProps; // 刚开始工作阶段的 props
	        this.memoizedProps = null; // 工作结束时确定下来的 props
	        this.memoizedState = null; // 更新完成后的新 state
	        this.updateQueue = null; // Fiber产生的更新操作都会放在更新队列中
	        this.alternate = null; // 用于 current Fiber树和 workInProgress Fiber树的切换（如果当时fiberNode树是current树，则alternate指向的是workInProgress树）
	        // 副作用
	        this.flags = NoFlags; // （比如插入 更改 删除dom等）初始状态时表示没有任何标记（因为还没进行fiberNode对比）
	        this.subtreeFlags = NoFlags; // 子节点副作用标识
	    }
	}
	class FiberRootNode {
	    container; // 保存宿主环境挂载的节点(DomELement或者原生组件)
	    current; // 指向当前渲染的Fiber树的根节点，也就是 hostRootFiber
	    finishedWork; // 指向完成更新后的新的Fiber树的根节点
	    constructor(container, hostRootFiber) {
	        this.container = container; // 保存宿主环境挂载的节点(DomELement或者原生组件)
	        this.current = hostRootFiber; // 指向当前渲染的Fiber树的根节点，也就是 hostRootFiber
	        hostRootFiber.stateNode = this; // 把当前 FiberRootNode 实例挂载到 hostRootFiber.stateNode 上
	        this.finishedWork = null; // 指向完成更新后的新的Fiber树的根节点
	    }
	}
	/**
	 * workInProgress Fiber表示渲染阶段正在处理的组件
	 * 该函数主要用来创建或复用一个workInProgress Fiber对象
	 * @param current 当前的Fiber对象
	 * @param pendingProps 新的属性对象
	 * @returns
	 */
	const createWorkInProgress = (current, pendingProps) => {
	    let wip = current.alternate;
	    if (wip === null) {
	        // mount阶段
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        // 创建一个新的 Fiber对象（HostFiberNode，例如根元素 div），并复制current的属性和标记
	        wip.type = current.type;
	        wip.stateNode = current.stateNode;
	        wip.alternate = current;
	        current.alternate = wip;
	    }
	    else {
	        // update阶段
	        // 复用，更新属性标记
	        wip.pendingProps = pendingProps;
	        // 清除副作用，可能是上一次更新遗留下来的
	        wip.flags = NoFlags;
	        // 子树的副作用标识
	        wip.subtreeFlags = NoFlags;
	    }
	    // 把 current节点对应的 fiber tree 上的工作单元复制到 wip上
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    wip.memoizedState = current.memoizedState;
	    return wip;
	};
	// 根据element创建 FiberNode
	function createFiberFromElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // <div>111</div> type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型', element);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	// 定义一个创建 Update实例的方法，返回值是一个 Update实例
	const createUpdate = (action) => {
	    return {
	        action
	    };
	};
	// 定义一个创建 UpdateQueue 队列实例的方法
	const createUpdateQueue = () => {
	    return {
	        shared: {
	            pending: null
	        },
	        dispatch: null
	    };
	};
	// 往 UpdateQueue 里增加 Update 更新操作的任务
	// 将 Update 插入到 UpdateQueue
	const enqueueUpdate = (UpdateQueue, Update) => {
	    UpdateQueue.shared.pending = Update;
	};
	// 定义一个 UpdateQueue 消费 Update实例的方法，遍历链表中的所有Update对象，并返回最新的state
	// 一个初始的状态，以及要消费的Update
	// 返回值是一个全新的状态
	const processUpdateQueue = (baseState, pendingUpdate) => {
	    const result = {
	        memoizedState: baseState
	    };
	    // 如果有正在消费的状态
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            // baseState 1 Update (x) => 4x -> memoizedState 4
	            result.memoizedState = action(baseState);
	        }
	        else {
	            // baseState 1 Update 2 ->  memoizedState 2
	            result.memoizedState = action;
	        }
	    }
	    return result;
	};

	// createInstance 用于创建宿主环境的实例，比如浏览器环境下的 DOM 元素
	// export const createInstance = (type: string, props: any):
	const createInstance = (type) => {
	    // TODO 处理 props
	    const element = document.createElement(type);
	    return element;
	};
	// 创建文本节点
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};
	// 插入子节点
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	// appendChildToContainer 用于将子节点插入到父节点中
	const appendChildToContainer = appendInitialChild;

	const completeWork = (wip) => {
	    // 递归中的归
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount 阶段
	                // 1.构建DOM
	                // 浏览器环境就是DOM节点，原生开发就是原生native组件
	                // const instance = createInstance(wip.type, newProps);
	                const instance = createInstance(wip.type);
	                // 2.将DOM插入到DOM树中，这步其实也就是将刚才递归遍历的DOM树，都挂载在统一的dom上
	                // 也就是构建离谱DOM树
	                appendAllChildren(instance, wip);
	                wip.stateNode = instance;
	            }
	            // 冒泡子树副作用标识
	            bubblePropertied(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount 阶段
	                // 1.构建DOM
	                // 浏览器环境就是DOM节点，原生开发就是原生native组件
	                const instance = createTextInstance(newProps.content); // newProps.conten： string || number
	                // 将文本属性生成的实例挂载在文本节点上
	                wip.stateNode = instance;
	                // 文本节点不存在 child
	            }
	            bubblePropertied(wip);
	            return null;
	        case HostRoot:
	            bubblePropertied(wip);
	            return null;
	        case FunctionComponent:
	            bubblePropertied(wip);
	            return null;
	        default:
	            {
	                console.warn('未处理的completeWork情况', wip);
	            }
	            break;
	    }
	};
	/*
	    <A>123</A>

	    <h1>
	        <A />
	        <A />
	    </h1>
	*/
	// 往 parent 节点中插入 wip，但有可能 wip 不是单独的元素，还有可能是组件，比如上面的情况
	function appendAllChildren(parent, wip) {
	    let node = wip.child;
	    while (node !== null) {
	        // 首先向下找
	        if (node.tag === HostComponent || node.tag === HostText) {
	            // 找到了就可以插入
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node.child !== null) {
	            // 如果没有要找的元素类型，也向下找
	            // A 组件里还有 child
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        // 归的阶段，回归到了本节点
	        if (node === wip) {
	            return;
	        }
	        // 向下找到头了，就开始向上找
	        while (node.sibling == null) {
	            // 往上归
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            node = node?.return;
	        }
	        // 建立联系
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	// completeWork性能优化策略：利用completeWork向上归的过程
	// 将子fiberNode的flags冒泡到父fiberNode
	function bubblePropertied(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    while (child !== null) {
	        // 将子节点的副作用标记集成到当前节点的副作用标识中
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        // 把当前节点的子节点和父节点联系起来
	        child.return = wip;
	        child = child.sibling;
	    }
	    // 将遍历到的所有 subtreeFlags 附加在当前 wip 的 subtreeFlags 上
	    wip.subtreeFlags |= subtreeFlags;
	}

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	// 为了不滥用 React.elemen，所以为它创建一个单独的键
	// 为React.element元素创建一个 symbol 并放入到 symbol 注册表中
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;

	/**
	 *
	 * @param shouldTrackEffects 代表需不需要标记副作用
	 * @returns 生成子节点，并标记副作用
	 */
	function ChildReconciler(shouldTrackEffects) {
	    // reconcilerSingleElement 根据元素的类型和属性创建一个新的fiber节点，并将其链接到当前fiber树上
	    function reconcilerSingleElement(returnFiber, currentFiber, element) {
	        // 根据element创建fiber，再返回
	        const fiber = createFiberFromElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function reconcilerSingleTextNode(returnFiber, currentFiber, content) {
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    // 插入单一节点并判断什么时候追踪副作用
	    function placeSingChild(fiber) {
	        // 刚创建的fiber 应该是正在工作的 fiber 单元，所以 fiber 是 workInProgress
	        // workInProgress.alternate 也就是 current fiber
	        if (shouldTrackEffects && fiber.alternate === null) {
	            // current fiber 是 null 的话也就是 首屏渲染
	            // 按位或运算
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    // 用来标记 fiberNode 的插入、删除、移动
	    return function reconcilerChildFibers(
	    /**
	     * returnFiber 父节点的 fiber
	     */
	    returnFiber, 
	    /**
	     * currentFiber 子节点的 currentFiber
	     */
	    currentFiber, 
	    /**
	     * newChild 子节点的 reactElement
	     */
	    newChild) {
	        // 判断当前 fiber 的类型
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingChild(reconcilerSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconciler类型', newChild);
	                    }
	                    break;
	            }
	        }
	        // HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingChild(reconcilerSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        {
	            console.warn('未实现的reconciler类型', newChild);
	        }
	        return null;
	    };
	}
	// update阶段 追踪副作用
	const reconcilerChildFibers = ChildReconciler(true);
	const mountChildFibers = ChildReconciler(false);

	// 使用 internals 变量获取内部数据层数据完成中转
	const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	// 当前正在渲染的函数组件的 FiberNode 用于保存当前函数组件里面 使用的 hooks
	let currentlyRenderingFiber = null;
	// 当前正在使用的 hook
	let workInProgressHook = null;
	const { currentDispatcher } = internals;
	/**
	 * 生成函数组件的子FiberNode
	 * @param wip 当前工作的 FiberNode 节点
	 */
	function renderWithHooks(wip) {
	    // 赋值操作
	    currentlyRenderingFiber = wip;
	    // 重置
	    wip.memoizedState = null;
	    // 判断时机
	    const current = wip.alternate;
	    if (current !== null) ;
	    else {
	        // mount
	        // 指向了 mount 时的 hooks 实现
	        currentDispatcher.current = HooksDispatcheronMount;
	    }
	    // 1. 获取当前组件的类型
	    const Component = wip.type;
	    // 2. 获取当前组件的 props
	    const props = wip.pendingProps;
	    // 3. 获取当前组件的 hooks
	    const children = Component(props);
	    // 重置操作
	    currentlyRenderingFiber = null;
	    return children;
	}
	/**
	 * 用于保存 mount 时的 hooks 实现
	 */
	const HooksDispatcheronMount = {
	    useState: mountState
	};
	function mountState(initialState) {
	    // 	找到当前useState对应的hook数据
	    const hook = mountWorkInProgressHook();
	    let memoizedState;
	    if (initialState instanceof Function) {
	        memoizedState = initialState();
	    }
	    else {
	        memoizedState = initialState;
	    }
	    // 为dispatch创建一个update更新队列
	    const queue = createUpdateQueue();
	    hook.updateQueue = queue;
	    // 为hook添加memoizedState
	    hook.memoizedSate = memoizedState;
	    // NOTE：dispatch 方法是可以不在 FC 组件内部调用的
	    // 这里预置了 fiber 和 queue 信息，用户只需要传递 action
	    // @ts-ignore
	    const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	    // 为queue添加dispatch方法
	    // 向更新队列中添加更新时，会调用dispatch方法
	    queue.dispatch = dispatch;
	    return [memoizedState, dispatch];
	}
	/**
	 * 让 useState 返回的 dispatch 接入更新队列，从而接入调度更新流程
	 * @param fiber
	 * @param updateQueue
	 * @param action
	 */
	function dispatchSetState(fiber, updateQueue, action) {
	    // 和接入首屏渲染的 update 流程相似
	    // 生成 update
	    const update = createUpdate(action);
	    // 将 update 接入到 updateQueue 中
	    enqueueUpdate(updateQueue, update);
	    // 接入调度更新流程
	    scheduleUpdateOnFiber(fiber);
	}
	/**
	 * 获取 mount 时的 hook 的数据
	 * @returns
	 */
	function mountWorkInProgressHook() {
	    // 不存在首先创建一个
	    const hook = {
	        memoizedSate: null,
	        updateQueue: null,
	        next: null
	    };
	    // hook 为空，说明是第一次使用
	    if (workInProgressHook === null) {
	        // mount 时的第一个 hook
	        if (currentlyRenderingFiber == null) {
	            // 因为 workInProgressHook 表示的是当前正在使用的函数组件的 fiberNode
	            // 说明不是在函数组件内调用 hook
	            throw new Error('请在函数组件内调用 hook');
	        }
	        else {
	            // 说明是在函数组件内调用 hook，并保存当前 hook
	            workInProgressHook = hook;
	            // 记录数据到 fiber 上
	            currentlyRenderingFiber.memoizedState = workInProgressHook;
	        }
	    }
	    else {
	        // mount 时的第二个 hook 以及之后的 hook，串联到链表上
	        workInProgressHook.next = hook;
	        // 指向了第二个hook
	        workInProgressHook = hook;
	    }
	    return workInProgressHook;
	}
	/*
	function App() {
	  return <Img />
	}
	*/

	// 递归中的递阶段
	/**
	 * 作用：1.计算状态的最新值 2. 创建子 FiberNode
	 * @param wip 当前工作的 FiberNode 节点
	 * @returns 返回值是子FiberNode
	 */
	const beginWork = (wip) => {
	    //  将当前 FiberNode 和 ReactElement 比较，生成子FiberNode
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            return null;
	        case FunctionComponent:
	            return updateFunctionComponent(wip);
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	            break;
	    }
	    return null;
	};
	// 计算状态的最新值，并生成 子FiberNode（会和processUpdateQueue 消费状态函数联系）
	// HostRootFiber
	function updateHostRoot(wip) {
	    // 基础的状态
	    const baseState = wip.memoizedState;
	    // 更新的状态
	    const updateQueue = wip.updateQueue;
	    // 获取参与计算的 update
	    const pending = updateQueue.shared.pending;
	    // 获取到之后把之前的 参与计算的 update 赋值 nul
	    updateQueue.shared.pending = null;
	    // memoizedState 已经是 HostRootFiber 状态的最新值了
	    const { memoizedState } = processUpdateQueue(baseState, pending);
	    wip.memoizedState = memoizedState;
	    // 接下来开始创建 子 FiberNode
	    const nextChildren = wip.memoizedState;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	// HostComponent： div p，它的状态更新在 commit，在这里它只需要对比新老props的差异
	// children 在 props 属性中
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * 生成子FiberNode
	 * @param wip 当前工作的 FiberNode 节点
	 * @param children 子节点的 reactElement
	 */
	function reconcilerChildren(wip, children) {
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        // 将子节点的 current fiberNode 和
	        // 子节点的 reactElement 对比生成子节点的wip fiberNode
	        wip.child = reconcilerChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mount
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}
	/**
	 *	计算函数组件的最新值 以及 创建子FiberNode
	 * @param wip 当前工作的 FiberNode 节点
	 */
	function updateFunctionComponent(wip) {
	    // 生成函数组件的子FiberNode
	    const nextChildren = renderWithHooks(wip);
	    // 根据子FiberNode 生成子FiberNode
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}

	// 保存下一个需要执行的effecct 节点
	let nextEffect = null;
	// commitMutationEffects 函数主要用来完成副作用的执行，包括重置文本节点以及真实的dom节点的插入、删除和更新等操作。
	const commitMutationEffects = (finishedWork) => {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        // 向下遍历
	        const child = nextEffect.child;
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            // 如果有子节点，且子节点有副作用，则将子节点作为下一个需要执行的effect节点
	            nextEffect = child;
	            continue;
	        }
	        else {
	            // 如果没有子节点，或者子节点没有副作用(也就是说不是叶子节点，可能遇到第一个没有subtreeFlags的节点)，则当前节点可能存在 Flags，有的话需要执行副作用
	            // 向上遍历
	            up: while (nextEffect !== null) {
	                // 如果当前节点有副作用，则执行副作用
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    // 如果有兄弟节点，且兄弟节点有副作用，则将兄弟节点作为下一个需要执行的effect节点
	                    break up;
	                }
	                // 如果没有兄弟节点，且父节点有副作用，则将父节点作为下一个需要执行的effect节点
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	};
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    if ((flags & Placement) !== NoFlags) {
	        // 执行插入操作等
	        commitPlacement(finishedWork);
	        // 将 Placement 标记从 finishedWork当前工作的节点中 清除
	        finishedWork.flags &= ~Placement;
	        // flags Update
	        // flags ChildDeletion
	    }
	};
	// commitPlacement 函数主要用来完成真实的dom节点的插入、删除和更新等操作。
	const commitPlacement = (finishedWork) => {
	    // 需要获取 parentFiber Dom节点
	    // 需要获取 finishedWork Dom节点
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parentFiber Dom节点
	    const hostParent = getHostParent(finishedWork);
	    // 1. finishedWork Dom节点  2. appendChild
	    if (hostParent !== null) {
	        appendPlacementNodeInToContainer(finishedWork, hostParent);
	    }
	};
	// 该函数用于获取宿主环境里当前节点的父节点
	/**
	 * 向上找到 fiber 最近的包含实际宿主环境节点 fiber 的宿主节点
	 * @param fiber
	 * @returns
	 */
	function getHostParent(fiber) {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        // HostComponent HostRoot
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        if (parent.tag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到host parent');
	    }
	    return null;
	}
	// 该函数用于将当前节点(fiber类型的)插入到宿主环境里的父节点中
	function appendPlacementNodeInToContainer(finishedWork, hostParent) {
	    // fiber 需要找到对应的dom节点，然而这个fiber节点可能是一个组件，所以需要调用createInstance方法来创建一个真实的dom节点
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        // 插入真实的dom节点
	        appendChildToContainer(hostParent, finishedWork.stateNode);
	        return;
	    }
	    // 递归向下的过程，直到我们找到一个真实的dom节点（HostComponent 或 HostText）
	    // 递归的过程中，会将所有的子节点和兄弟节点都插入到宿主环境里的父节点中
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeInToContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeInToContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	}

	// TODO：需要一个全局的指针，指向当时正在工作的 fiberNode 树，一般是 workInProgress
	// 指向当前工作单元的指针
	let workInProgress = null;
	// 用于进行初始化的操作
	function prepareFreshStack(root) {
	    // 初始化将指针指向第一个fiberNode（root）
	    workInProgress = createWorkInProgress(root.current, {});
	}
	/*
	markUpdateFromFiberToRoot 函数的作用是将一个Fiber节点的更新标记打上，
	然后将这个标记一直向上遍历父节点，直到遍历到根节点，将根节点的更新标记也打上。
	这个函数通常在一个组件内部的Fiber树上的更新发生时被调用，用于标记哪些组件需要更新，
	然后将这些标记一直向上冒泡，最后标记整个应用需要更新。
	*/
	// 找到根节点，从根节点开始更新整个组件
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode; // 此时的 HostRootFiber 指向 FiberRootNode
	    }
	    // 可能是Portal节点，也可能是 Suspense节点
	    return null;
	}
	// 在fiber中更新调度
	function scheduleUpdateOnFiber(fiber) {
	    // 调度功能 xxx
	    const root = markUpdateFromFiberToRoot(fiber);
	    renderRoot(root);
	}
	// 作用是用来创建fiber树，进而和更新流程联系起来
	// 那么可以推测出调用 renderRoot 应该是触发更新的 api
	function renderRoot(root) {
	    // 初始化
	    prepareFreshStack(root);
	    // 执行递归
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (e) {
	            // 开发环境会被编译成 true，生产环境会被编译为 false
	            {
	                console.log('workLoop发生错误', e);
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    // 这个 finishedWork 已经是完成递归阶段两个函数生成的 workInProgress 树了
	    // 此时的 wip 已经包含了某些 Placement 副作用的标记了。
	    const finishedWork = root.current.alternate;
	    root.finishedWork = finishedWork;
	    // 根据 wip fiberNode树和树中的flags执行具体的Dom操作了。
	    // 接下来实行 react-dom下的首屏渲染流程了
	    // 从根节点开始，递归执行 commitWork
	    commitRoot(root);
	}
	function commitRoot(root) {
	    // root.finishedWork 为 workInProgress
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishedWork);
	    }
	    // 重置 finishedWork
	    root.finishedWork = null;
	    // 判断是否存在三个子阶段需要执行的操作
	    // root flags root subtreeFlags
	    const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        // beforeMutation
	        // 主要实现 mutation Placement
	        commitMutationEffects(finishedWork);
	        // 双缓冲树的更新
	        root.current = finishedWork;
	        // layout
	    }
	    else {
	        root.current = finishedWork;
	    }
	}
	// 该函数用于调度和执行 FiberNode 树的更新和渲染过程
	// 该函数的作用是处理 React 程序中更新请求，计算 FiberNode 树中的每个节点的变化，并把这些变化同步到浏览器的DOM中
	function workLoop() {
	    while (workInProgress !== null) {
	        // 开始执行每个工作单元的工作
	        performUmitOfWork(workInProgress);
	    }
	}
	// 在这个函数中，React 会计算 FiberNode 节点的变化，并更新 workInProgress
	function performUmitOfWork(fiber) {
	    // 如果有子节点，就一直遍历子节点
	    const next = beginWork(fiber);
	    // 递执行完之后，需要更新下工作单元的props
	    fiber.memoizedProps = fiber.pendingProps;
	    // 没有子节点的 FiberNode 了，代表递归到最深层了。
	    if (next === null) {
	        completeUnitOfWork(fiber);
	    }
	    else {
	        // 如果有子节点的 FiberNode，则更新子节点为新的 fiberNode 继续执行
	        workInProgress = next;
	    }
	}
	// 主要进行归的过程，向上遍历父节点以及兄弟，更新它们节点的变化，并更新 workInProgress
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        // 归：没有子节点之后开始向上遍历父节点
	        completeWork(node);
	        const sibling = node.sibling;
	        if (sibling !== null) {
	            // 有兄弟节点时，将指针指到兄弟节点
	            workInProgress = sibling;
	            return;
	        }
	        // 兄弟节点不存在时，递归应该继续往上指到父亲节点
	        node = node.return;
	        workInProgress = node;
	    } while (node !== null);
	}

	// 创建整个应用的根节点 FiberRootNode，并将它与 hostRootFiber 链接起来
	// 在执行ReactDOM.createRoot()的时候会执行
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    // 与之前的更新流程联系
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	// 创建update，并enqueueUpdateQueue中，并将更新机制和首屏渲染hostRootFiber联系起来
	// 在执行ReactDOM.createRoot(rootElement).render(<App />) 时执行，主要是 render
	function updateContainer(element, root) {
	    const hostRootFiber = root.current; // FiberRootNode实例指向的保存DOM结构的根节点
	    // 接下来开始首屏渲染更新
	    const update = createUpdate(element);
	    // 将首屏渲染和触发更新机制联系了起来
	    // 将update插入到hostRootFiber中的updateQueue中
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    // 触发函数更新，并调用scheduleUpdateOnFiber函数里的 renderRoot函数创建一个新的Fiber树
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}
	// TODO：创建了mount时的api，并把api接入了更新流程
	// api指 ReactDOM.createRoot(rootElement).render(<App />)

	// ReactDOM.createRoot(root).render(<App />);
	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
